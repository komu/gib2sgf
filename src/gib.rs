//! Parsing GIB files generated by Tygem.
//!
//! The format is reverse engineered from actual Tygem files with some help of
//! https://senseis.xmp.net/?GIB
//!
//! Things not yet supported:
//!   - handicaps
//!   - mapping most ranks
//!   - time settings
//!   - probably many different interesting things
//!
use std::collections::HashMap;
use regex::Regex;
use crate::go::{PlayerColor, BoardCoordinate, Score, GameResult, Handicap};
use std::ops::Index;
use std::num::ParseIntError;
use datetime::{LocalDate, Month};

#[derive(Debug)]
pub struct Gib {
    raw_attributes: HashMap<String, String>,
    handicap: Option<Handicap>,
    moves: Vec<GoMove>,
}

#[derive(Debug)]
pub struct GoMove {
    pub player: PlayerColor,
    pub coordinate: BoardCoordinate,
}

type GibResult<T> = Result<T, GibParseError>;

pub type GibParseError = String;

impl Gib {
    pub fn parse(str: &str) -> GibResult<Gib> {
        let metadata_regex = Regex::new(r"^\\\[(\w+)=(.*)\\]$").unwrap();
        let move_regex = Regex::new(r"^STO 0 (\d+) (\d+) (\d+) (\d+)\s*$").unwrap();
        let ini_regex = Regex::new(r"^INI \d+ \d+ (\d+) .+$").unwrap();

        let mut raw_attributes = HashMap::new();
        let mut moves = Vec::new();
        let mut handicap: Option<Handicap> = None;

        // Technically there's a separate header section separated by "\HS" and "\HE" lines
        // and a game section separated by "\GS" and "\GE" lines. We don't care about that
        // and just loop through everything looking for lines that match our regexes.

        for line in str.lines() {
            if let Some(captures) = metadata_regex.captures(line) {
                let key = captures.index(1);
                let value = captures.index(2);
                raw_attributes.insert(key.to_string(), value.to_string());

            } else if let Some(captures) = move_regex.captures(line) {
                // Assume that the moves are in order and we don't need move numbers for anything
                moves.push(GoMove {
                    player: PlayerColor::from_gib(captures.index(2))?,
                    coordinate: BoardCoordinate::from_gib(captures.index(3), captures.index(4))?,
                });
            } else if let Some(captures) = ini_regex.captures(line) {
                let handicap_str = captures.index(1);
                let stones: u8 = handicap_str.parse().map_err(|_| format!("invalid handicap: {}", handicap_str))?;
                handicap = Handicap::from(stones);
            }
        }

        Ok(Gib { raw_attributes, handicap, moves })
    }

    pub fn get_moves(&self) -> &Vec<GoMove> {
        &self.moves
    }

    pub fn get_handicap(&self) -> Option<Handicap> {
        self.handicap
    }

    fn get_attribute(&self, name: &str) -> Option<&str> {
        self.raw_attributes.get(name).map(|s| s.as_str())
    }

    pub fn get_nick(&self, color: PlayerColor) -> Option<&str> {
        self.get_attribute(color.pick("GAMEBLACKNICK", "GAMEWHITENICK"))
    }

    pub fn get_rank(&self, color: PlayerColor) -> Option<&str> {
        self.get_attribute(color.pick("GAMEBLACKLEVEL", "GAMEWHITELEVEL")).map(convert_rank)
    }

    pub fn get_komi(&self) -> Option<Score> {
        self.get_attribute("GAMEGONGJE").map(Score::from_gib).flatten()
    }

    pub fn get_result(&self) -> Option<GameResult> {
        self.get_attribute("GAMEINFOMAIN").map(GameResult::from_gib).flatten()
    }

    pub fn get_date(&self) -> Option<LocalDate> {
        self.get_attribute("GAMEDATE").map(parse_gib_date).flatten()
    }

    pub fn get_game_place(&self) -> Option<&str> {
        self.get_attribute("GAMEPLACE")
    }
}

impl Score {
    fn from_gib(score: &str) -> Option<Score> {
        let score10: i32 = score.parse().ok()?;
        Some(Score::new(score10 as f32 / 10.0))
    }
}

impl BoardCoordinate {
    fn from_gib(x: &str, y: &str) -> GibResult<BoardCoordinate> {
        Ok(BoardCoordinate {
            x: x.parse().map_err(|e: ParseIntError| e.to_string())?,
            y: y.parse().map_err(|e: ParseIntError| e.to_string())?,
        })
    }
}

impl PlayerColor {
    fn from_gib(s: &str) -> Result<PlayerColor, GibParseError> {
        match s {
            "1" => Ok(PlayerColor::Black),
            "2" => Ok(PlayerColor::White),
            _ => Err(format!("invalid player: '{}'", s))
        }
    }
}


impl GameResult {
    fn parse_info_attributes(s: &str) -> HashMap<String, String> {
        let regex = Regex::new(r"^([^:]+):(.*)$").unwrap();

        let mut result = HashMap::new();

        for part in s.split(",") {
            if let Some(captures) = regex.captures(part) {
                result.insert(captures.index(1).to_string(), captures.index(2).to_string());
            }
        }

        result
    }

    fn from_gib(game_info_main: &str) -> Option<GameResult> {
        let attributes = GameResult::parse_info_attributes(game_info_main);

        let score = attributes.get("ZIPSU").map(|s| Score::from_gib(s.as_str())).flatten();
        let grlt = attributes.get("GRLT")?.as_str();
        match grlt {
            "0" => Some(GameResult::Count(PlayerColor::Black, score)),
            "1" => Some(GameResult::Count(PlayerColor::White, score)),
            "3" => Some(GameResult::Resign(PlayerColor::Black)),
            "4" => Some(GameResult::Resign(PlayerColor::White)),
            "7" => Some(GameResult::Time(PlayerColor::Black)),
            "8" => Some(GameResult::Time(PlayerColor::White)),
            _ => None
        }
    }
}

fn parse_gib_date(str: &str) -> Option<LocalDate> {
    let regex = Regex::new(r"^(\d{4})- ?(\d*)- ?(\d*)(-.+)?$").unwrap();

    let captures = regex.captures(str)?;
    let year: i64 = captures.index(1).parse().ok()?;
    let month = Month::from_one(captures.index(2).parse().ok()?).ok()?;
    let day: i8 = captures.index(3).parse().ok()?;
    LocalDate::ymd(year, month, day).ok()
}

fn convert_rank(level: &str) -> &str {
    match level {
        "18" => "1d",
        "19" => "2d",
        "20" => "3d",
        "21" => "4d",
        "22" => "5d",
        "23" => "6d",
        "24" => "7d",
        "25" => "8d",
        "26" => "9d",
        _ => level  // TODO
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::go::PlayerColor::Black;

    #[test]
    fn test_parsing() {
        let gib = Gib::parse(r#"\HS
\[GAMEGONGJE=65\]
\[GAMEDATE=2020- 3-13-23-21-56\]
\[GAMEPLACE=Tygem Baduk\]
\[GAMEWHITELEVEL=19\]
\[GAMEWHITENICK=TheWhite\]
\[GAMEBLACKLEVEL=19\]
\[GAMEBLACKNICK=TheBlack\]
\[GAMEINFOMAIN=GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0\]
\HE
\GS
2 1 0
186 0 &4
INI 0 1 0 &4
STO 0 2 1 16 3
STO 0 3 2 15 16
\GE
"#).unwrap();

        assert_eq!(gib.get_nick(PlayerColor::Black), Some("TheBlack"));
        assert_eq!(gib.get_nick(PlayerColor::White), Some("TheWhite"));
        assert_eq!(gib.get_rank(PlayerColor::White), Some("2d"));
        assert_eq!(gib.get_rank(PlayerColor::Black), Some("2d"));
        assert_eq!(gib.get_komi(), Some(Score::new(6.5)));
        assert_eq!(gib.get_date(), LocalDate::ymd(2020, Month::March, 13).ok());
        assert_eq!(gib.get_game_place(), Some("Tygem Baduk"));

        assert_eq!(gib.get_moves().len(), 2);
        assert_eq!(gib.get_moves().index(0).player, PlayerColor::Black);
        assert_eq!(gib.get_moves().index(0).coordinate, BoardCoordinate::new(16, 3));
        assert_eq!(gib.get_moves().index(1).player, PlayerColor::White);
        assert_eq!(gib.get_moves().index(1).coordinate, BoardCoordinate::new(15, 16));
    }

    #[test]
    fn test_date_parsing() {
        assert_eq!(parse_gib_date("2020- 3-13-23-21-56"), LocalDate::ymd(2020, Month::March, 13).ok());
    }

    #[test]
    fn test_result_parsing() {
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Resign(Black)));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:0,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Count(Black, Some(Score::new(3.5)))));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:7,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Time(Black)));
    }
}
