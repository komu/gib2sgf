//! Parsing GIB files generated by Tygem.
//!
//! The format is reverse engineered from actual Tygem files with some help of
//! https://senseis.xmp.net/?GIB
//!
//! Things not yet supported:
//!   - handicaps
//!   - time settings
//!   - probably many different interesting things
//!
use std::collections::HashMap;
use std::num::ParseIntError;
use crate::go::{PlayerColor, BoardCoordinate, Score, GameResult, Handicap};
use crate::time::LocalDate;

#[derive(Debug)]
pub struct Gib {
    raw_attributes: HashMap<String, String>,
    handicap: Option<Handicap>,
    moves: Vec<GoMove>,
}

#[derive(Debug)]
pub struct GoMove {
    pub player: PlayerColor,
    pub coordinate: BoardCoordinate,
}

type GibResult<T> = Result<T, GibParseError>;

pub type GibParseError = String;

impl Gib {
    pub fn parse(str: &str) -> GibResult<Gib> {
        let mut raw_attributes = HashMap::new();
        let mut moves = Vec::new();
        let mut handicap: Option<Handicap> = None;

        // Technically there's a separate header section separated by "\HS" and "\HE" lines
        // and a game section separated by "\GS" and "\GE" lines. We don't care about that
        // and just loop through everything looking for lines that match our regexes.

        for line in str.lines() {
            if let Some((key, value)) = parse_metadata_line(line) {
                raw_attributes.insert(key.to_string(), value.to_string());
            } else if let Some(mv) = parse_move_line(line) {
                moves.push(mv);
            } else if let Some(hc) = parse_handicap_line(line) {
                handicap = Some(hc);
            }
        }

        Ok(Gib { raw_attributes, handicap, moves })
    }

    pub fn get_moves(&self) -> &Vec<GoMove> {
        &self.moves
    }

    pub fn get_handicap(&self) -> Option<Handicap> {
        self.handicap
    }

    fn get_attribute(&self, name: &str) -> Option<&str> {
        self.raw_attributes.get(name).map(|s| s.as_str())
    }

    pub fn get_nick(&self, color: PlayerColor) -> Option<&str> {
        let attribute = self.get_attribute(color.pick("GAMEBLACKNAME", "GAMEWHITENAME"))?;
        let (name, _) = parse_gib_name(attribute)?;
        Some(name)
    }

    pub fn get_rank(&self, color: PlayerColor) -> Option<&str> {
        let attribute = self.get_attribute(color.pick("GAMEBLACKNAME", "GAMEWHITENAME"))?;
        let (_, rank) = parse_gib_name(attribute)?;
        Some(rank)
    }

    pub fn get_komi(&self) -> Option<Score> {
        self.get_attribute("GAMEGONGJE").map(Score::from_gib).flatten()
    }

    pub fn get_result(&self) -> Option<GameResult> {
        self.get_attribute("GAMEINFOMAIN").map(GameResult::from_gib).flatten()
    }

    pub fn get_date(&self) -> Option<LocalDate> {
        self.get_attribute("GAMEDATE").map(parse_gib_date).flatten()
    }

    pub fn get_game_place(&self) -> Option<&str> {
        self.get_attribute("GAMEPLACE")
    }
}

impl Score {
    fn from_gib(score: &str) -> Option<Score> {
        let score10: i32 = score.parse().ok()?;
        Some(Score::new(score10 as f32 / 10.0))
    }
}

impl BoardCoordinate {
    fn from_gib(x: &str, y: &str) -> GibResult<BoardCoordinate> {
        Ok(BoardCoordinate {
            x: x.parse().map_err(|e: ParseIntError| e.to_string())?,
            y: y.parse().map_err(|e: ParseIntError| e.to_string())?,
        })
    }
}

impl PlayerColor {
    fn from_gib(s: &str) -> Result<PlayerColor, GibParseError> {
        match s {
            "1" => Ok(PlayerColor::Black),
            "2" => Ok(PlayerColor::White),
            _ => Err(format!("invalid player: '{}'", s))
        }
    }
}


impl GameResult {
    fn parse_info_attributes(s: &str) -> HashMap<String, String> {
        let mut result = HashMap::new();

        for part in s.split(',') {
            if let Some(pos) = part.find(':') {
                let key = &part[..pos];
                let value = &part[pos + 1..];

                result.insert(key.to_string(), value.to_string());
            }
        }

        result
    }

    fn from_gib(game_info_main: &str) -> Option<GameResult> {
        let attributes = GameResult::parse_info_attributes(game_info_main);

        let score = attributes.get("ZIPSU").map(|s| Score::from_gib(s.as_str())).flatten();
        let grlt = attributes.get("GRLT")?.as_str();
        match grlt {
            "0" => Some(GameResult::Count(PlayerColor::Black, score)),
            "1" => Some(GameResult::Count(PlayerColor::White, score)),
            "3" => Some(GameResult::Resign(PlayerColor::Black)),
            "4" => Some(GameResult::Resign(PlayerColor::White)),
            "7" => Some(GameResult::Time(PlayerColor::Black)),
            "8" => Some(GameResult::Time(PlayerColor::White)),
            _ => None
        }
    }
}

fn parse_gib_date(str: &str) -> Option<LocalDate> {
    let mut lexer = Lexer::new(str);

    let year = lexer.read_until("- ").parse::<i16>().ok()?;
    lexer.skip_while("- ");
    let month = lexer.read_until("- ").parse::<i8>().ok()?;
    lexer.skip_while("- ");
    let day = lexer.read_until("- ").parse::<i8>().ok()?;

    LocalDate::ymd(year, month, day)
}

/// Extract name and rank from name attribute of form `name (rank)`.
fn parse_gib_name(str: &str) -> Option<(&str, &str)> {
    if str.ends_with(')') {
        if let Some(index) = str.find(" (") {
            let name = &str[..index];
            let rank = &str[index + 2..str.len() - 1];
            return Some((name, rank));
        }
    }

    None
}

/// Extract key and value from line of form `\[key=value\]`
fn parse_metadata_line(str: &str) -> Option<(&str, &str)> {
    let trimmed = str.trim();
    if trimmed.starts_with(r"\[") && trimmed.ends_with(r"\]") {
        if let Some(index) = trimmed.find('=') {
            let name = &trimmed[2..index];
            let value = &trimmed[index + 1..trimmed.len() - 2];
            return Some((name, value));
        }
    }
    None
}

/// Extract move from line of form `STO 0 <num> <player> <x> <y`
///
/// Assumes that the moves are in order and we don't need move numbers for anything
fn parse_move_line(str: &str) -> Option<GoMove> {
    let trimmed = str.trim();

    let prefix = "STO 0 ";
    if trimmed.starts_with(prefix) {
        let mut lexer = Lexer::new(&trimmed[prefix.len()..]);

        lexer.read_until(" "); // num
        lexer.skip_while(" ");
        let player = PlayerColor::from_gib(lexer.read_until(" ")).ok()?;
        lexer.skip_while(" ");
        let x = lexer.read_until(" ");
        lexer.skip_while(" ");
        let y = lexer.read_until(" ");
        let coordinate = BoardCoordinate::from_gib(x, y).ok()?;

        return Some(GoMove { player, coordinate })
    }

    None
}

/// Extract handicap from line of form `INI <num> <num> <handicap>`
fn parse_handicap_line(str: &str) -> Option<Handicap> {
    let trimmed = str.trim();

    let prefix = "INI ";
    if trimmed.starts_with(prefix) {
        let mut lexer = Lexer::new(&trimmed[prefix.len()..]);

        lexer.read_until(" "); // first num
        lexer.skip_while(" ");

        lexer.read_until(" "); // second num
        lexer.skip_while(" ");

        let stones = lexer.read_until(" ").parse::<u8>().ok()?;
        lexer.skip_while(" ");
        return Handicap::from(stones)
    }

    None
}

struct Lexer<'a> {
    str: &'a str,
    pos: usize,
}

impl <'a> Lexer<'a> {
    fn new(str: &str) -> Lexer {
        Lexer { str, pos: 0 }
    }

    fn read_until(&mut self, separators: &str) -> &'a str {
        let start = self.pos;

        while self.pos < self.str.len() && !separators.contains(&self.str[self.pos..self.pos + 1]) {
            self.pos += 1;
        }

        return &self.str[start..self.pos];
    }

    fn skip_while(&mut self, characters: &str) {
        while self.pos < self.str.len() && characters.contains(&self.str[self.pos..self.pos + 1]) {
            self.pos += 1;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::go::PlayerColor::Black;

    #[test]
    fn test_parsing() {
        let gib = Gib::parse(r#"\HS
\[GAMEGONGJE=65\]
\[GAMEDATE=2020- 3-13-23-21-56\]
\[GAMEPLACE=Tygem Baduk\]
\[GAMEWHITENAME=TheWhite (2D)\]
\[GAMEBLACKNAME=TheBlack (2D)\]
\[GAMEINFOMAIN=GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0\]
\HE
\GS
2 1 0
186 0 &4
INI 0 1 0 &4
STO 0 2 1 16 3
STO 0 3 2 15 16
\GE
"#).unwrap();

        assert_eq!(gib.get_nick(PlayerColor::Black), Some("TheBlack"));
        assert_eq!(gib.get_nick(PlayerColor::White), Some("TheWhite"));
        assert_eq!(gib.get_rank(PlayerColor::White), Some("2D"));
        assert_eq!(gib.get_rank(PlayerColor::Black), Some("2D"));
        assert_eq!(gib.get_komi(), Some(Score::new(6.5)));
        assert_eq!(gib.get_date(), LocalDate::ymd(2020, 3, 13));
        assert_eq!(gib.get_game_place(), Some("Tygem Baduk"));

        assert_eq!(gib.get_moves().len(), 2);
        assert_eq!(gib.get_moves()[0].player, PlayerColor::Black);
        assert_eq!(gib.get_moves()[0].coordinate, BoardCoordinate::new(16, 3));
        assert_eq!(gib.get_moves()[1].player, PlayerColor::White);
        assert_eq!(gib.get_moves()[1].coordinate, BoardCoordinate::new(15, 16));
    }

    #[test]
    fn test_date_parsing() {
        assert_eq!(parse_gib_date("2020- 3-13-23-21-56"), LocalDate::ymd(2020, 3, 13));
    }

    #[test]
    fn test_result_parsing() {
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Resign(Black)));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:0,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Count(Black, Some(Score::new(3.5)))));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:7,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Time(Black)));
    }

    #[test]
    fn test_parse_name() {
        assert_eq!(parse_gib_name(""), None);
        assert_eq!(parse_gib_name("Foo"), None);
        assert_eq!(parse_gib_name("Foo (2D)"), Some(("Foo", "2D")));
    }
}
