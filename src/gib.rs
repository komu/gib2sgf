//! Parsing GIB files generated by Tygem.
//!
//! The format is reverse engineered from actual Tygem files with some help of
//! https://senseis.xmp.net/?GIB
//!
//! Things not yet supported:
//!   - handicaps
//!   - time settings
//!   - probably many different interesting things
//!
use std::collections::HashMap;
use crate::go::{PlayerColor, Score, GameResult, Handicap, GoMove};
use crate::time::LocalDate;
use crate::lexer::Lexer;

#[derive(Debug)]
pub struct Gib {
    raw_attributes: HashMap<String, String>,
    handicap: Option<Handicap>,
    moves: Vec<GoMove>,
}

type GibResult<T> = Result<T, GibParseError>;

pub type GibParseError = String;

impl Gib {
    pub fn parse(str: &str) -> GibResult<Gib> {
        let mut raw_attributes = HashMap::new();
        let mut moves = Vec::new();
        let mut handicap: Option<Handicap> = None;

        // Technically there's a separate header section separated by "\HS" and "\HE" lines
        // and a game section separated by "\GS" and "\GE" lines. We don't care about that
        // and just loop through everything looking for lines that match our patterns.

        for line in str.lines() {
            if line.starts_with(r"\[") {
                let (key, value) = parse_metadata_line(line)?;
                raw_attributes.insert(key.to_string(), value.to_string());
            } else if line.starts_with("STO ") {
                moves.push(parse_place_stone(line)?);
            } else if line.starts_with("SKI") {
                // TODO: pass
            } else if line.starts_with("INI ") {
                handicap = parse_handicap_line(line)?;
            } else if line == r"\HS" || line == r"\HE" || line == r"\GS" || line == r"\GE" {
                // ignore known
            } else if line == "2 1 0" || line == "2 5 0" || line.ends_with("&4") {
                // ignore known 2
            } else {
                // ignore for now
            }
        }

        Ok(Gib { raw_attributes, handicap, moves })
    }

    pub fn get_moves(&self) -> &Vec<GoMove> {
        &self.moves
    }

    pub fn get_handicap(&self) -> Option<Handicap> {
        self.handicap
    }

    fn get_attribute(&self, name: &str) -> Option<&str> {
        self.raw_attributes.get(name).map(|s| s.as_str())
    }

    pub fn get_nick(&self, color: PlayerColor) -> Option<&str> {
        let attribute = self.get_attribute(color.pick("GAMEBLACKNAME", "GAMEWHITENAME"))?;
        parse_gib_name(attribute).0
    }

    pub fn get_rank(&self, color: PlayerColor) -> Option<&str> {
        let attribute = self.get_attribute(color.pick("GAMEBLACKNAME", "GAMEWHITENAME"))?;
        parse_gib_name(attribute).1
    }

    pub fn get_komi(&self) -> Option<Score> {
        self.get_attribute("GAMEGONGJE").map(Score::from_gib).flatten()
    }

    pub fn get_result(&self) -> Option<GameResult> {
        self.get_attribute("GAMEINFOMAIN").map(GameResult::from_gib).flatten()
    }

    pub fn get_date(&self) -> Option<LocalDate> {
        self.get_attribute("GAMEDATE").map(|d| parse_gib_date(d).ok()).flatten()
    }

    pub fn get_game_place(&self) -> Option<&str> {
        self.get_attribute("GAMEPLACE")
    }
}

impl Score {
    fn from_gib(score: &str) -> Option<Score> {
        let score10: i32 = score.parse().ok()?;
        Some(Score::new(score10 as f32 / 10.0))
    }
}

impl PlayerColor {
    fn from_gib(s: &str) -> Result<PlayerColor, GibParseError> {
        match s {
            "1" => Ok(PlayerColor::Black),
            "2" => Ok(PlayerColor::White),
            _ => Err(format!("invalid player: '{}'", s))
        }
    }
}

impl GameResult {
    fn parse_info_attributes(s: &str) -> HashMap<String, String> {
        let mut result = HashMap::new();

        for part in s.split(',') {
            if let Some(pos) = part.find(':') {
                let key = &part[..pos];
                let value = &part[pos + 1..];

                result.insert(key.to_string(), value.to_string());
            }
        }

        result
    }

    fn from_gib(game_info_main: &str) -> Option<GameResult> {
        let attributes = GameResult::parse_info_attributes(game_info_main);

        let score = attributes.get("ZIPSU").map(|s| Score::from_gib(s.as_str())).flatten();
        let grlt = attributes.get("GRLT")?.as_str();
        match grlt {
            "0" => Some(GameResult::Count(PlayerColor::Black, score)),
            "1" => Some(GameResult::Count(PlayerColor::White, score)),
            "3" => Some(GameResult::Resign(PlayerColor::Black)),
            "4" => Some(GameResult::Resign(PlayerColor::White)),
            "7" => Some(GameResult::Time(PlayerColor::Black)),
            "8" => Some(GameResult::Time(PlayerColor::White)),
            _ => None
        }
    }
}

/// Parses gib-formatted date into a LocalDate
fn parse_gib_date(str: &str) -> GibResult<LocalDate> {
    let mut lexer = Lexer::new(str);

    let year = lexer.read_number::<u16>()?;
    lexer.expect("-")?;
    lexer.optional(" ");
    let month = lexer.read_number::<u8>()?;
    lexer.expect("-")?;
    lexer.optional(" ");
    let day = lexer.read_number::<u8>()?;

    LocalDate::ymd(year, month, day)
}

/// Extract name and rank from name attribute of form `name (rank)`.
fn parse_gib_name(str: &str) -> (Option<&str>, Option<&str>) {
    if str.is_empty() {
        return (None, None);
    }

    if str.ends_with(')') {
        if let Some(index) = str.find(" (") {
            let name = &str[..index];
            let rank = &str[index + 2..str.len() - 1];
            return (Some(name), Some(rank));
        }
    }

    (Some(str), None)
}

/// Extract key and value from line of form `\[key=value\]`
fn parse_metadata_line(str: &str) -> GibResult<(&str, &str)> {
    let trimmed = str.trim();
    if trimmed.starts_with(r"\[") && trimmed.ends_with(r"\]") {
        let contents = &trimmed[2..trimmed.len() - 2];
        if let Some(index) = contents.find('=') {
            let name = &contents[..index];
            let value = &contents[index + 1..];
            return Ok((name, value));
        }
    }
    Err(format!("invalid metadata line: '{}'", str))
}

/// Extract move from line of form `STO <num> <num> <player> <x> <y>`
///
/// Assumes that the moves are in order and we don't need move numbers for anything
fn parse_place_stone(str: &str) -> GibResult<GoMove> {
    let mut lexer = Lexer::new(str);
    lexer.expect("STO ")?;

    lexer.read_number::<i16>()?;
    lexer.expect(" ")?;
    lexer.read_number::<i16>()?;
    lexer.expect(" ")?;
    let player = PlayerColor::from_gib(lexer.read_while(|c| c != ' '))?;
    lexer.expect(" ")?;
    let x = lexer.read_number::<u8>()?;
    lexer.expect(" ")?;
    let y = lexer.read_number::<u8>()?;

    Ok(GoMove::place_stone(player, (x, y)))
}

/// Extract handicap from line of form `INI <num> <num> <handicap>`
fn parse_handicap_line(str: &str) -> GibResult<Option<Handicap>> {
    let trimmed = str.trim();

    let prefix = "INI ";
    let mut lexer = Lexer::new(&trimmed[prefix.len()..]);

    lexer.read_number::<i16>()?;
    lexer.expect(" ")?;

    lexer.read_number::<i16>()?;
    lexer.expect(" ")?;

    let stones = lexer.read_number::<u8>()?;

    Ok(Handicap::from(stones))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::go::{GoMove, PlayerColor::{Black, White}};

    #[test]
    fn test_parsing() {
        let gib = Gib::parse(r#"\HS
\[GAMEGONGJE=65\]
\[GAMEDATE=2020- 3-13-23-21-56\]
\[GAMEPLACE=Tygem Baduk\]
\[GAMEWHITENAME=TheWhite (2D)\]
\[GAMEBLACKNAME=TheBlack (2D)\]
\[GAMEINFOMAIN=GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0\]
\HE
\GS
2 1 0
186 0 &4
INI 0 1 0 &4
STO 0 2 1 16 3
STO 0 3 2 15 16
\GE
"#).unwrap();

        assert_eq!(gib.get_nick(PlayerColor::Black), Some("TheBlack"));
        assert_eq!(gib.get_nick(PlayerColor::White), Some("TheWhite"));
        assert_eq!(gib.get_rank(PlayerColor::White), Some("2D"));
        assert_eq!(gib.get_rank(PlayerColor::Black), Some("2D"));
        assert_eq!(gib.get_komi(), Some(Score::new(6.5)));
        assert_eq!(gib.get_date(), LocalDate::ymd(2020, 3, 13).ok());
        assert_eq!(gib.get_game_place(), Some("Tygem Baduk"));

        assert_eq!(gib.get_moves().len(), 2);
        assert_eq!(gib.get_moves()[0], GoMove::place_stone(Black, (16, 3)));
        assert_eq!(gib.get_moves()[1], GoMove::place_stone(White, (15, 16)));
    }

    #[test]
    fn test_date_parsing() {
        assert_eq!(parse_gib_date("2020-10-13-23-21-56"), LocalDate::ymd(2020, 10, 13));
        assert_eq!(parse_gib_date("2020-10- 5-23-21-56"), LocalDate::ymd(2020, 10, 5));
        assert_eq!(parse_gib_date("2020- 3-13-23-21-56"), LocalDate::ymd(2020, 3, 13));
        assert_eq!(parse_gib_date("2021- 3- 4- 3- 1- 6"), LocalDate::ymd(2021, 3, 4));
    }

    #[test]
    fn test_result_parsing() {
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:3,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Resign(Black)));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:0,ZIPSU:35,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Count(Black, Some(Score::new(3.5)))));
        assert_eq!(GameResult::from_gib("GBKIND:3,GTYPE:0,GCDT:0,GTIME:600-30-3,GRLT:7,ZIPSU:0,DUM:0,GONGJE:65,TCNT:185,AUSZ:0"), Some(GameResult::Time(Black)));
    }

    #[test]
    fn test_parse_name() {
        assert_eq!(parse_gib_name(""), (None, None));
        assert_eq!(parse_gib_name("Foo"), (Some("Foo"), None));
        assert_eq!(parse_gib_name("Foo (2D)"), (Some("Foo"), Some("2D")));
    }
}
